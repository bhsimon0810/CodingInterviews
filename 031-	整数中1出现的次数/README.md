# 整数中 1 出现的次数

本文是[《剑指Offer》](https://www.nowcoder.com/ta/coding-interviews?page=1)刷题笔记，记录刷题过程中的体会与收获。

## 题目描述

输入整数 n，求从 1 到 n 范围内所有整数的十进制表示中 1 出现的次数。例如输入 12，从 1 到 12 这些整数中包含 1 的数字有 1, 10, 11 和 12 共出现五次。

## 解题思路

要求整数中 1 出现的次数，最直接的解法为：对于数字 n 可以对 10 取模判断个位数是否为 1，然后再整除 10 继续统计十位、百位等；从 1 遍历到 n 即可统计出所有整数 1 出现的次数。或者将整数转换为字符串，判断包含字符 1 的个数。显然这种解法复杂度较高且不够优雅，下面我们再来思考更高级的解法。

思路一：设整数 n = abcde，其中 abcde 分别表示十进制中各位数字。以**输入整数 n 的百位数字为例**，来统计从 1 到 n 范围内百位数为 1 的数字个数。

- 如果百位数为 0，百位上出现 1 的次数由更高位决定。比如输入 12013，百位上出现 1 的次数有 100-199, 1100-1199, ..., 11100-11199 共 1200 次。可以发现这种情况下由高位数字（12）乘当前位数（100）
- 如果百位数为 1，百位上出现 1 的次数除了由高位部分决定外，还包括低位数的部分。比如输入 12113，高位部分共 1200 次外，还包括来自低位部分的 12100-12113 共 14 次。因此增多的低位部分为低位数字（13）加 1
- 如果百位数大于 1，此时百位出现 1 的次数仅由高位决定。比如输入 12213，对应百位数为 1 的次数有 100-199, ..., 12100-12199 共 1300 次。因此这种情况的次数为高位数字加 1 再乘当前位数

思路二：我们还可以换一种思考方式。

首先考察个位数，1 会每隔 10 出现一次，例如 1、11、21 等等，我们发现以 10 为一个阶梯的话，每一个完整的阶梯里面都有一个 1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯 0-9, 10-19 之中都有一个 1，但是 19 之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现 1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）：

> **n/10 \* 1+(n%10!=0 ? 1 : 0)**

现在说十位数，十位数上出现 1 的情况应该是 10-19，依然沿用分析个位数时候的阶梯理论，我们知道 10-19 这组数，每隔 100 出现一次，这次我们的阶梯是 100，例如数字 317，分析有阶梯 0-99, 100-199, 200-299 三段完整阶梯，每一段阶梯里面都会出现 10 次 1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于 19，那么直接算 10 个 1 就行了，因为 10-19肯定会出现；如果小于 10，那么肯定不会出现十位数的 1；如果在 10-19 之间的，我们计算结果应该是 k - 10 + 1。例如我们分析 300-317，17个数字，1 出现的个数应该是 17 - 10 + 1 = 8 个：

> - 设 k = n % 100，即为不完整阶梯段的数字
> - **(n / 100) \* 10 + (if(k > 19) 10 else if(k < 10) 0 else k - 10 + 1)**

因此递推式可表示为：

> - k = n % (i * 10)
> - **count(i) = (n / (i \* 10)) \* i + (if(k > i \* 2 - 1) i else if(k < i) 0 else k - i + 1)**

将 `if-else` 比较语句替换成 `min/max` 可让代码更简洁。

## 代码示例

```C++
/* 
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int count = 0; // 出现 1 的次数
        int i = 1; // 当前位数
        int current = 0, before = 0, after = 0;
        
        while(n / i) 
        {
            current = (n / i) % 10;
            before = n / (i * 10);
            after = n - (n / i) * i;

            if(current == 0)
                count += before * i;
            else if(current == 1)
                count += before * i + after + 1;
            else 
                count += (before + 1) * i;
            
            i *= 10;
        }

        return count;
    }
};*/

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0) return 0;
        int count = 0;
        for(int i = 1; i <= n; i *= 10) {
            int div = i * 10;
            count += (n / div) * i + min(max(n % div - i + 1, 0), i);
        }
        return count;
    }
};
```

## 相关阅读

[整数中 1 出现的次数](https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?f=discussion)
