# 二进制中 1 的个数

本文是[《剑指Offer》](https://www.nowcoder.com/ta/coding-interviews?page=1) 刷题笔记，记录刷题过程中的体会与收获。

## 题目描述

输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。

## 解题思路

判断输入整数二进制形式中 1 的个数，最直接的思路是从二进制形式末位开始与 1 按位与运算，若结果为零表示二进制形式末位为 0，否则为 1；然后对二进制数向右移位操作继续判断新的末位元素是否为 1。在此基础上统计二进制形式中 1 的个数。相应的代码示例为

```C++
int NumberOf1(int n) {
    int count = 0;
    while(n) {
        if(n & 1)
            count++;
        n = n >> 1;
    }
    return count;
}
```

但仔细思考过后，不难发现以上思路对于正整数是可行的，但对于负整数，因为计算机以补码形式储存整数，所以在向右移位过程中高位要补符号位，因此语句 `while(n)` 可能会造成死循环。

因此为了避免这种情况发生，可行的做法是不对输入的整数向右移位，而对进行按位与运算的 1 向左移位。向左移位过程中低位始终补零，因此无需考虑符号位的影响。相应的代码示例为

```C++
int NumberOf1(int n) {
    int count = 0;
    unsigned int flag = 1;
    while(flag) {
        if(n & flag)
            count++;
        flag = flag << 1;
    }
    return count;
}
```

这种方法虽然可行，但对于 32 位整数而言就要移位 32 次，可能会造成不必要的计算开销。因此仍需要尝试可以改进的方法。

考虑将整数减去 1 的结果，反映到二进制形式就是将最右边的 1 变成 0；若最右边的 1 右边还有 0，减法结果是右边的 0 全变为 1。因此可以考虑 $n$ 和 $n - 1$ 按位与运算，其结果就是每次将整数 $n$ 最右边的 1 变为 0 并且其余位置的数值并不受影响。因此循环取与运算会将整数 $n$ 中所有的 1 全部变为 0。容易验证这种思路对负整数同样成立，因为整数以补码形式储存并参与运算。

## 代码示例

```C++
class Solution {
public:
     int NumberOf1(int n) {
         int count = 0;
         while(n) {
             count++;
             n = n & (n - 1);
         }
         return count;
     }
};
```

